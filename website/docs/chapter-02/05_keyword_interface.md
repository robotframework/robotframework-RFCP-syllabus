
# 2.5 Keyword Interface and Documentation

::::lo[Learning Objectives]

:::K2[LO-2.5]

Understand the structure of keyword interfaces and how to interpret keyword documentation.

:::

::::

Library Keywords and User Keywords that are defined in a resource file should have a documentation text that describes what the keyword does and how it should be used.

Robot Framework is capable of generating **Keyword Documentation** files that contains a library- or resource-documentation, all keywords, their argument interfaces, and their documentation texts.
This documentation file can be generated with the `libdoc` command and can be used to provide a reference for users who want to use the keywords.

Basically all standard and external 3rd party libraries offer these Keyword Documentations as online available HTML pages.

Robot Framework offers the Keyword Documentation of its Standard Libraries at https://robotframework.org/robotframework .

<!-- Keywords from Libraries and Resources can be called and can be documented either as HTML or in IDEs with Robot Support. -->



## 2.5.1 Documented Keyword Information

::::lo[Learning Objectives]

:::K1[LO-2.5.1]

Recall the information that can be found in a keyword documentation.

:::

::::

The Keyword Documentation is structured so, that it contains first the library or resource documentation, followed by a list of all keywords that are available in that library or resource file.

Each library or resource documentation can contain the following information sections for keywords:
- **Name**: The name of the keyword as it is called.
- **Arguments** (opt.): The argument interface that the keyword expects/offers its types and default values.
- **Return Type** (opt.): The type of the return value of the keyword.
- (*) **Tags** (opt.): The tags that are assigned to the keyword to categorize keywords.
- **Documentation** (opt.): The documentation text that describes what the keyword does and how it should be used.

(*) Understanding keyword tags is not part of the syllabus.

The following keywords are part of the Standard Libraries of Robot Framework.
Their documentation has been generated by the Robot Framework tool `libdoc` which is included in Robot Framework.

### 2.5.1.1 Example Keyword `Should Be Equal`

[Documentation of `Should Be Equal` from `BuiltIn` library](https://robotframework.org/robotframework/latest/libraries/BuiltIn.html#Should%20Be%20Equal)

`Should Be Equal` is part of the BuiltIn library and is documented as follows:

![Should Be Equal Keyword Documentation](/img/Should_Be_Equal_Docs.png)

This keyword has 2 "Mandatory Arguments" and 6 "Optional Arguments".
All of them can be called positionally or by name.


### 2.5.1.2 Example Keyword `Run Process`

[Documentation of `Run Process` from `Process` library](https://robotframework.org/robotframework/latest/libraries/Process.html#Run%20Process)

`Run Process` is part of the Process library and is documented as follows:

![Run Process Keyword Documentation](/img/Run_Process_Docs.png)

This keyword has one Mandatory Arguments `command` which can be called positionally or by name.
The latter two arguments are optional.

The argument `arguments` is a :term[Variable Number of Positional Arguments] and can only be set by position.
Therefore, if it shall be set, all preceding arguments must be set by position as well.
See [2.5.2.5 Variable Number of Positional Arguments](chapter-02/05_keyword_interface.md#2525-variable-number-of-positional-arguments) for more information about this kind of argument.

The argument `configuration` is a :term[Free Named Argument] and can only be set by names.
See [2.5.2.7 Free Named Arguments](chapter-02/05_keyword_interface.md#2527-free-named-arguments) for more information about this kind of argument.


### 2.5.1.3 Example Keyword `Get Regexp Matches`

[Documentation of `Get Regexp Matches` from `String` library](https://robotframework.org/robotframework/latest/libraries/String.html#Get%20Regexp%20Matches)

`Get Regexp Matches` is part of the String library and is documented as follows:

![Get Regexp Matches Keyword Documentation](/img/Get_Regexp_Matches_Docs.png)

This keyword has 2 "Mandatory Arguments" that can be called positionally or by name.
The last two arguments are optional.

The argument `groups` is a :term[Variable Number of Positional Arguments] and can only be set by position.
Therefore, if it shall be set, all preceding arguments must be set by position as well.
See [2.5.2.5 Variable Number of Positional Arguments](chapter-02/05_keyword_interface.md#2525-variable-number-of-positional-arguments) for more information about this kind of argument.

The argument `flags` is a :term[Named-Only Argument] and can only be set by name.
See [2.5.2.6 Named-Only Arguments](chapter-02/05_keyword_interface.md#2526-named-only-arguments) for more information about this kind of argument.


## 2.5.2 Keyword Arguments

::::lo[Learning Objectives]

:::K2[LO-2.5.2]

Understand the difference between argument kinds.

:::

::::

Most library keywords can be parameterized with arguments that are passed to the keyword when it is called to customize its behavior.
The more business oriented keywords are the less arguments they typically have.

Keyword arguments can be grouped into different argument kinds.
On the one hand you can group them by their definition attributes and on the other hand by their usage kind.

The relevant distinction of usage kinds is between using :term[Positional Arguments]{term="Positional Argument"}, :term[Named Arguments]{term="Named Argument"}, or :term[Embedded Arguments]{term="Embedded Argument"}.
How to use them is described in [2.6 Writing Test|Task and Calling Keywords](chapter-02/06_writing_test.md).

Another important information is if an argument is mandatory or optional.
See the next two sections for more information about these two kinds of arguments.

Most arguments can either be set by their position or by their name.
But there are some kinds of arguments that can only be set positionally, like :term[Variable Number of Positional Arguments], or only be set named, like :term[Named-Only Arguments]{term="Named-Only Argument"} or :term[Free Named Arguments]{term="Free Named Argument"}.

The order is as follows:
1. :term[Positional or Named Arguments]{term="Positional or Named Argument"} (can be mandatory or optional)
2. :term[Variable Number of Positional Arguments] (optional)
3. :term[Named-Only Arguments]{term="Named-Only Argument"} (can be mandatory or optional)
4. :term[Free Named Arguments]{term="Free Named Argument"} (optional)

### 2.5.2.1 Mandatory Arguments

::::lo[Learning Objectives]

:::K2[LO-2.5.2.1]

Understand the concept of mandatory arguments and how they are documented.

:::

::::

Arguments that do not have a default value, must be set when the keyword is called.
These arguments have to be before arguments with default values in the argument interface of the keywords.

See the argument named `first` and `second` in the `Should Be Equal` keyword documentation in the beginning of this section.

If too few arguments are provided, the keyword call will fail with an error message.

Example:
```robotframework
*** Test Cases ***
Tests Will Pass
    Should Be Equal    One    One

Test Will Fail
    Should Be Equal    One    Two

Test Will Fail Due to Missing Args
    Should Be Equal    One
```

The first Test will pass, because both argument values are equal.
The second Test will fail, because the argument values are not equal.
The third Test will fail before the keyword `Should Be Equal` is actually being executed, because the keyword expects at least two arguments.
The Error Message would be: `Keyword 'BuiltIn.Should Be Equal' expected 2 to 8 arguments, got 1.`

Two arguments are mandatory and the additional six arguments are optional in the `Should Be Equal` keyword.


### 2.5.2.2 Optional Arguments

::::lo[Learning Objectives]

:::K2[LO-2.5.2.2]

Understand the concept of optional arguments and how they are documented.

:::

::::

Arguments that have a default value can be omitted when the keyword is called, causing these arguments to be set to their default value.
These arguments are listed after the mandatory arguments in the argument interface.
Default values are defined and represented in the docs by the equal sign `=` after the argument name and a value after that.

Also :term[Variable Number of Positional Arguments], represented with a single star (`*`) prefix, and :term[Free Named Arguments]{term="Free Named Argument"}, represented with a double star (`**`) prefix are optional arguments.

E.g. the argument `msg` in the `Should Be Equal` keyword documentation has the default value `None` and `ignore_case` has the default value `False`.

In that particular keyword these optional arguments can be used to activate some special features like ignoring the case of the compared strings or to provide a custom error message.

Omitting some optional arguments but still using others is possible independent of their order by setting these arguments by their name. See [2.6 Writing Test|Task and Calling Keywords](chapter-02/06_writing_test.md).



### 2.5.2.3 Embedded Arguments

::::lo[Learning Objectives]

:::K1[LO-2.5.2.3]

Recall the concept of keywords with embedded arguments used in Behavior-Driven Specification and how they are documented.

:::

::::

Keywords can include arguments embedded directly into their names, a feature primarily used for Behavior-Driven Development (BDD).
Embedded arguments are mandatory and must be provided in the exact position defined within the keyword name.

Keyword names include arguments defined using the scalar variable syntax with dollar and curly braces (`${var_name}`).
This syntax explicitly defines these as arguments, distinguishing them from the rest of the keyword name.

Example keyword names are:
- `"${url}" is open`
- `the user clicks the "${button}" button`
- `the page title should be ${exp_title}`
- `the url should be ${exp_url}`

Example Test Case:
```robotframework
*** Test Cases ***
Foundation Page should be Accessible
    Given "robotframework.org" is open
    When the user clicks the "FOUNDATION" button
    Then the page title should be Foundation | Robot Framework
    And the url should be https://robotframework.org/foundation
```
The optional prefixes `Given`, `When`, `Then`, `And` and `But` are basically ignored by Robot Framework if a keyword is found matching the rest of the name including the embedded arguments.
In the example :term[test case] some keywords are designed so that the arguments are surrounded by double quotes (`"`) for better visibility.

A mix of embedded arguments and "normal" arguments is possible to fully support BDD.
In the keyword documentation the embedded arguments are written in variable syntax with dollar-curly-braces (`${var_name}`) to indicate that they are not part of the keyword name but are arguments.
They can also be defined using regular expressions to allow for more complex argument structures, which is not part of this syllabus.


### 2.5.2.4 Positional or Named Arguments

::::lo[Learning Objectives]

:::K1[LO-2.5.2.4]

Recall how "Positional or Named Arguments" are marked in the documentation and their use case.

:::

::::

Except for "Positional-Only Arguments", which are not part of this syllabus,
all arguments that are positioned before :term[Variable Number of Positional Arguments], :term[Named-Only Arguments]{term="Named-Only Argument"}, or :term[Free Named Arguments]{term="Free Named Argument"} in the argument interface of a keyword are :term[Positional or Named Arguments]{term="Positional or Named Argument"}.

As their name states, they can be set either by their position or by their name, but not by both at the same time for one argument.
If an argument shall be set by its position, all preceding arguments must be set by their position as well.

These arguments can either be mandatory or optional with a default value.

They are not specially marked in the keyword documentation with any prefix, because they are the default kind of arguments in Robot Framework.


### 2.5.2.5 Variable Number of Positional Arguments

::::lo[Learning Objectives]

:::K1[LO-2.5.2.5]

Recall how "Variable Number of Positional Arguments" are marked in the documentation and their use case.

:::

::::

A special case of optional arguments that can only be set by their position are :term[Variable Number of Positional Arguments].
These are also referred to as `*args` or `*varargs` in Python.
Some keywords need to collect a variable amount of values into one argument, because it is not possible to define the amount of values in advance.

One example for this kind of keyword is [2.5.1.2 Example Keyword `Run Process`](chapter-02/05_keyword_interface.md#2512-example-keyword-run-process) from the Process library.
This keyword executes a `command` with variable amount of `arguments` and waits for the process to finish.
Depending on the command to be executed different amount of arguments are needed for that command.

This variable argument is marked with a single asterisk `*` before the argument name in the keyword documentation.

When calling this keyword, the first positional argument is assigned to `command`, while all subsequent positional arguments are collected into `arguments`.
Because of this behavior, no additional positional arguments can be used after these :term[Variable Number of Positional Arguments].
As a result, any arguments following these :term[Variable Number of Positional Arguments] must be named arguments,
regardless of whether they are mandatory or optional arguments with a default value.

Also see [2.5.1.3 Example Keyword `Get Regexp Matches`](chapter-02/05_keyword_interface.md#2513-example-keyword-get-regexp-matches).


### 2.5.2.6 Named-Only Arguments

::::lo[Learning Objectives]

:::K1[LO-2.5.2.6]

Recall what properties "Named-Only Arguments" have and how they are documented.

:::

::::

All arguments that are defined after a :term[Variable Number of Positional Arguments] (`*varargs`) are :term[Named-Only Arguments]{term="Named-Only Argument"}.
However it is also possible to create "Named-Only Arguments without a preceding :term[Variable Number of Positional Arguments].

:term[Named-Only Arguments]{term="Named-Only Argument"} are marked with a "LABEL" sign `üè∑` before the argument name in the keyword documentation.

Those arguments can not be set positionally. All positional values would be consumed by the :term[Variable Number of Positional Arguments].
So they must be called by their name followed by an equal sign `=` and the value of the argument.

:term[Named-Only Arguments]{term="Named-Only Argument"} can be mandatory or optional with a default value.

### 2.5.2.7 Free Named Arguments

::::lo[Learning Objectives]

:::K1[LO-2.5.2.7]

Recall how "Free Named Arguments" are marked in documentation.

:::

::::

Another special case of :term[Named-Only Arguments]{term="Named-Only Argument"} are :term[Free Named Arguments]{term="Free Named Argument"}.
These arguments are similar to the :term[Variable Number of Positional Arguments] in that they can collect multiple values.
However, instead of collecting positional values, they gather all named values that are not explicitly defined as argument names.
In this case all values given to the keyword as arguments, that do contain an unescaped equal sign (`=`) are considered as named arguments.

Free named arguments are marked with two asterisks `**` before the argument name in the keyword documentation.

The example of the `Run Process` keyword also has a free named argument `** configuration`.

When calling this keyword all named arguments that are not explicitly defined as argument names are collected into the `configuration` argument and will be available as a dictionary in the keyword implementation.

They are optional and can be omitted.

With this configuration it is possible to e.g. redirect the output of the process to a file or to set the working directory of the process.

Example redirecting stdout and stderr to a file:
```robotframework
*** Test Cases ***
Send 5 IPv4 Pings On Windows
    Run Process   ping   -n   5   -4   localhost   stdout=ping_output.txt   stderr=ping_error.txt
```


### 2.5.2.8 Argument Types

::::lo[Learning Objectives]

:::K2[LO-2.5.2.8]

Understand the concept of argument types and automatic type conversion.

:::

::::

Keywords may define the expected types of their argument values.
The Robot Framework specification is predominantly a string-based language, therefore most statically defined argument values are strings.
However, the actual implementation of the keyword may expect a different type of argument, like an integer.

If an argument type is defined and Robot Framework has a matching converter function available, that can convert the given type to the expected type, the conversion is tried automatically.
If the conversion fails, the keyword call will fail with an error message before the actual keyword code is executed.
Robot Framework brings some built-in converters for common types like integer, float, boolean, list, dictionary, etc.
Library developers can also register their own converters for none-supported types.

Defining types for arguments is nowadays the recommended way to let Robot Framework convert the given arguments to the expected type, however it is optional.

Lets imagine a keyword that clicks on a specific coordinate on the screen, e.g. `Click On Coordinates`.
This keyword would expect two integer arguments, one for the `x`-coordinate and one for the `y`-coordinate.

That keyword can now claim that it expects two integer arguments by defining type hints for these arguments.
Type hints are shown in the keyword documentation at the arguments after the optional default value.

Robot Framework in that case tries to convert the given string arguments to the integer type.

Example:
```robotframework
*** Test Cases ***
Test Conversion
    Click On Coordinates    10    20    # This will work
    Click On Coordinates    10    Not_A_Number  # This will fail
```

In the first call the keyword will be called with the integer values `10` and `20` and will work as expected.
The second keyword call will fail, because the second argument is not a number and cannot be converted to an integer.
The error message would be: `ValueError: Argument 'y' got value 'Not_A_Number' that cannot be converted to integer.`

The advantage of using type hints is that the user get more information about what kind of values are expected and the keyword implementation can be simpler, because it can rely on the arguments being of the expected type.

<!-- Just to understand that they are there and that they may document how values are handled or which are allowed. -->


### 2.5.2.9 Return Types

::::lo[Learning Objectives]

:::K2[LO-2.5.2.9]

Understand the concept of return type hints.

:::

::::

Keywords may gather information and return these to the caller of that keyword to be stored in a variable and used in further keyword calls.
So, a keyword can `RETURN` values to the caller as functions do in programming languages.

If the keyword implementation offers a type hint for the return value, this is documented in the keyword documentation.
Similar to the argument types, return types are optional and a more recent feature of Robot Framework and therefore not widely used, yet.

It is important to know that keywords without a return type hint are often still returning values!
This is typically documented in the *Documentation* part of the keyword documentation.

<!-- Keywords may gather information and return these to the caller of that keyword. A Documented Return Value may be present but often it is just written in the docs, due to new feature -->



## 2.5.3 Keyword Documentation & Examples

::::lo[Learning Objectives]

:::K2[LO-2.5.3]

Understand how to read keyword documentation and how to interpret the examples.

:::

::::

Keyword documentation is an important part of the keyword implementation.
Good keyword names that clearly communicate what a keyword does are even more important,
but this should not give the impression that descriptive documentation is unnecessary.

Documentation is sometimes lean and sometimes extensive, depending on the complexity of the keyword.
The documentation should describe what the keyword does, how it should be used, and what the expected arguments and possible returned values are.
Depending on the complexity it may also be useful to provide examples of how the keyword can be used.

User Keywords typically have less extensive documentation because they are used in a narrower context and cannot be configured with arguments as much as library keywords from generic external libraries.

Examples in the documentation are commonly either written in table format or as code blocks.

**Table Example of `Should Be Equal`**:
| | | | | |
| - | - | - | - | - |
| Should Be Equal | `${x}` | expected | | |
| Should Be Equal | `${x}` | expected | Custom error message | |
| Should Be Equal | `${x}` | expected | Custom message | values=False |
| Should Be Equal | `${x}` | expected | ignore_case=True | formatter=repr |

Code block example:
```robotframework
Should Be Equal    ${x}    expected
Should Be Equal    ${x}    expected    Custom error message
Should Be Equal    ${x}    expected    Custom message    values=False
Should Be Equal    ${x}    expected    ignore_case=True    formatter=repr
```




